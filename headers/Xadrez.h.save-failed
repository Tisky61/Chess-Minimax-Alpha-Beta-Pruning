#ifndef XADREZ_H_INCLUDED
#define XADREZ_H_INCLUDED

#define preto false
#define branco true
#define JOGADA_PERFEITA 200000
typedef unsigned char smallint;
typedef std::pair<smallint,smallint> pii;
typedef std::pair<pii,pii> Movimento;
enum Pecas {ERROR_INVALID = -200,P_R = -6,P_Q = -5,P_B = -4,P_C = -3,P_T = -2,P_P = -1,vz = 0,
            B_R =  6,B_Q =  5,B_B =  4,B_C =  3,B_T =  2,B_P =  1};
class Xadrez {
public:
    Pecas tabuleiro[8][8];
    bool Dominio[8][8];
    std::pair<bool,bool> Castling[2];///Castling branco: 0, Castling preto: 1
    bool turno;
    Movimento EnPessant[2];///Nao implementado
    int pontuacao = 0;///Inutil, apenas para testes
    void domzero(void) {memset(&Dominio[0][0],0,sizeof(Dominio));}
    void domset(int x,int y){Dominio[x][y]=true;}void domset(pii a)   {domset (a.first,a.second);}
    void domzero(int x,int y){Dominio[x][y]=false;}void domzero(pii a){domzero(a.first,a.second);}
    int Reiniciar(void) {
        const static Pecas TabuleiroModelo[8][8] {{P_T,P_C,P_B,P_R,P_Q,P_B,P_C,P_T},
                                                  {P_P,P_P,P_P,P_P,P_P,P_P,P_P,P_P},
                                                  {vz ,vz ,vz ,vz ,vz ,vz ,vz ,vz },
                                                  {vz ,vz ,vz ,vz ,vz ,vz ,vz ,vz },
                                                  {vz ,vz ,vz ,vz ,vz ,vz ,vz ,vz },
                                                  {vz ,vz ,vz ,vz ,vz ,vz ,vz ,vz },
                                                  {B_P,B_P,B_P,B_P,B_P,B_P,B_P,B_P},
                                                  {B_T,B_C,B_B,B_R,B_Q,B_B,B_C,B_T}};
        turno = branco;///Rei e rainha trocados!!!
        pontuacao = 0;
        memcpy(&tabuleiro[0][0],&TabuleiroModelo[0][0],sizeof(tabuleiro));
        memset(Castling,0,sizeof(Castling));
        domzero();
    }
    Xadrez(){Reiniciar();}
    int Valor(Pecas c) {
        switch(abs(c)){case B_R:return 20000;case B_Q:return 9;case B_B: return 3;
                       case B_C:return 3;case B_T:return 5;case B_P: return 1;break;}
    }
    int EvaluateBlack(void) {
        int total = 0;
        Pecas* y = &tabuleiro[0][0];
        for(;y!=&tabuleiro[7][8];++y){
            switch(*y){case P_R:total+=200000;break;case P_Q:total+=9;break;case P_B:total+=3;break;
                      case P_C:total+=3;break;case P_T:total+=5;break;case P_P: ++total;break;}}
        return total;
    }
    int EvaluateWhite(void) {
        int total = 0;
        Pecas* y = &tabuleiro[0][0];
        for(;y!=&tabuleiro[7][8];++y){
            switch(*y){case B_R:total+=200000;break;case B_Q:total+=9;break;case B_B:total+=3;break;
                      case B_C:total+=3;break;case B_T:total+=5;break;case B_P: ++total;break;}}
        return total;
    }
    int EvaluateBoard(bool position) {
        const auto White = EvaluateWhite();
        const auto Black = EvaluateBlack();
        if(position==branco){
            const auto Score = White-Black;
            //if(Score<-20000) return -2000000 + Score; ///Max negative score
            //if(Score>20000 ) return 2000000 - Score; ///Max score
            return Score;
        } else {
            const auto Score = Black-White;
            //if(Score<-20000) return -2000000 + Score; ///Max negative score
            //if(Score>20000 ) return 2000000 - Score; ///Max score
            return Score;
        }
    }
    Pecas get (int i,int j) {if(i>-1&&i<8&&j>-1&&j<8)return tabuleiro[i][j];else return ERROR_INVALID;}
    auto operator()(int i,int j){return get(i,j);}
    void CheckVitoria() {
        /*
        if(EvaluateBlack()<2000)printf("Vitoria do branco!!!\n");
        if(EvaluateWhite()<2000)printf("Vitoria do preto!!!\n");*/
    }
    bool Move(Movimento b) {///Importante!!!Adicionar proibicao de castling
        const auto peca = get(b.second.first,b.second.second);
        const auto inimigo = get(b.first.first,b.first.second);
        switch(abs(peca)) {
            case B_R:
                ///Executar o castling
                if(peca>0) {///Branco
                    Castling[1] = std::pair<bool,bool>(true,true);
                    const int castling_identifier = b.first.second-b.second.second;
                    if(abs(castling_identifier)==2) {
                        ///Castling
                        if(castling_identifier>0){///Direita
                            tabuleiro[7][7] = vz;///[7][6] para o rei
                            tabuleiro[7][4] = B_T;
                        }else {///Esquerda
                            tabuleiro[7][0] = vz;
                            tabuleiro[7][2] = B_T;
                        }
                        goto normal;
                    }
                    goto normal;
                }else {///Preto
                    Castling[0] = std::pair<bool,bool>(true,true);
                    const int castling_identifier = b.first.second-b.second.second;
                    if(abs(castling_identifier)==2) {
                        ///Castling
                        if(castling_identifier>0){///Direita
                            tabuleiro[0][7] = vz;
                            tabuleiro[0][4] = P_T;
                        }else {///Esquerda
                            tabuleiro[0][0] = vz;
                            tabuleiro[0][2] = P_T;
                        }
                        goto normal;
                    }
                    goto normal;
                }
            break;
            case B_T:
                if(peca>0) {///Branco
                    if(b.second.first==7&&b.second.second==7) {
                        Castling[1].second = true;
                    }else if(b.second.first==7&&b.second.second==0) {
                        Castling[1].first  = true;
                    }
                }else {///Preto
                    if(b.second.first==0&&b.second.second==7) {
                        Castling[0].second = true;
                    }else if(b.second.first==0&&b.second.second==0) {
                        Castling[0].first  = true;
                    }
                }
            goto normal;
            case B_P:
                if(peca>0) {///Branco
                    if(!b.first.first) {
                        tabuleiro[b.first.first][b.first.second] = B_Q;///Queening
                        tabuleiro[b.second.first][b.second.second] = vz;
                        pontuacao -= (Valor(B_Q) - Valor(B_P));
                        break;
                    }
                }else {///Preto
                    if(b.first.first==7) {
                        tabuleiro[b.first.first][b.first.second] = P_Q;///Queening
                        tabuleiro[b.second.first][b.second.second] = vz;
                        pontuacao += (Valor(B_Q) - Valor(B_P));
                        break;
                    }
                }
            default:
                normal:
                    if(b.first.second<0 ||b.first.second>8||b.first.first<0 ||b.first.first>8) break;
                    if(b.second.second<0 ||b.second.second>8||b.second.first<0 ||b.second.first>8) break;
                    if(tabuleiro[b.first.first][b.first.second]>0){
                        ///Branco
                        pontuacao += Valor(tabuleiro[b.first.first][b.first.second]);
                    }else /**Preto**/ pontuacao -= Valor(tabuleiro[b.first.first][b.first.second]);
                    tabuleiro[b.first.first][b.first.second] = tabuleiro[b.second.first][b.second.second];
                    tabuleiro[b.second.first][b.second.second] = vz;
        }
        if(abs(inimigo) == B_R) return true;
        return false;
        CheckVitoria();
    }
};

#endif // XADREZ_H_INCLUDED
